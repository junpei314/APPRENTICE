1. オブジェクト志向の目的
オブジェクト志向が何のためにあるのか
・オブジェクト指向とは、「従来の複雑で難しいプログラミング言語を効率的なソフトウェア開発のために考えられた概念」
    「モノ」のことでさまざまな複雑なデータを1つのモノとし、複雑なプログラミングをオブジェクトにまとめた開発形式です。
    イメージとしては、「モノを操作する」考え方．データを1つのモノとして、モノを操作するイメージ．テレビというモノに対し、リモコンで操作するイメージ
    全てのデータ（オブジェクト）は何かしらのクラスの設計図に基づいて作られたものなので、必ず何かしらのクラスに属している。

2. カプセル化
オブジェクト指向におけるカプセル化とはどのような概念か、プログラミング初心者にわかるように説明してください。
・オブジェクト指向では、「カプセル化」することで、プログラムのセキュリティを強めることがでる．
    カプセル化とは、オブジェクトの情報を隠し、外部からの不正な操作を防ぐ仕組みで、アクセス制限のようなもの．
    オブジェクトに関するデータを操作するには、アクセス権限が必要となる．カプセルで情報を保護しているイメージ．

3. 継承
オブジェクト指向における継承とはどのような概念か、プログラミング初心者にわかるように説明してください。
・継承を使用してそのクラスの共通の振る舞いを簡単に再利用できるため，コードの重複が減り，保守性が向上する

    動物の分類に関連するプログラムを考えてみましょう。すべての動物には共通の特徴がありますが、特定の動物には独自の特徴もあります。
    このケースでは、Animalクラスを基本クラスとして作成し、その後個々の動物クラスを継承させることができます。
    まず、基本クラスとなるAnimalクラスを定義しましょう

class Animal
  def initialize(name)
    @name = name
  end

  def speak
    puts "私は#{@name}です。"
  end
end

class Dog < Animal
  def speak
    super
    puts "ワンワン！"
  end
end

class Cat < Animal
  def speak
    super
    puts "ニャー！"
  end
end

    この例では、DogクラスとCatクラスは共通の基本クラスであるAnimalを継承しています。
    これにより、DogクラスとCatクラスは共通のメソッドinitializeとspeakを引き継ぎます。
    speakメソッドは独自の振る舞いを追加するためにオーバーライドされています。

dog = Dog.new("ポチ")
cat = Cat.new("タマ")

dog.speak
# "私はポチです。"
# "ワンワン！"

cat.speak
# "私はタマです。"
# "ニャー！"

    この例では、継承を使用して共通の振る舞いを簡単に再利用でき、各動物クラスに特有の機能を追加できます。
    これにより、コードの重複が減り、保守性が向上します。


4. ポリモーフィズム
オブジェクト指向におけるポリモーフィズムとはどのような概念か、プログラミング初心者にわかるように説明してください。
・呼び出し側は同じメソッドを実行しているが，命令を受け取ったオブジェクト側でそれぞれ異なる動作をすること.
    これによりオブジェクトの方に依存せずに，同じ操作を実行できる．

https://savvycode.dev/programming-object-oriented-polymorphism/

5. 単一責任の原則
オブジェクト指向の重要な設計原則である「単一責任の原則」について、プログラミング初心者にわかるように説明してください。
・クラスが担う責任はたった一つに限定すべきとする設計原則．
以下具体例
    あるECサイトで割引サービスが追加されることになりました。商品1点につき300円割引される仕様です。この割引を通常割引と呼ぶことにします。
    その後、夏季限定割引の仕様が追加されることになりました。
    この割引は通常割引とはいろいろ仕様が異なるものの、 商品1点につき300円割引される仕様は通常割引と同じでした。
    通常割引ロジックの実装者とは別の人が実装担当することになりました。
    この担当者は「DiscountManagerに既に300円割り引くロジックが実装されてるじゃないか。これを流用しよう」と判断し、
    夏季限定割引を管理するプラグラムに通常割引のプログラムを組み込みました．
    その結果夏季限定割引がしようと違うインシデントを起こしました．
    DiscountManagerは通常割引の価格計算において正常動作を保証するために実装されたロジックであり，
    後から登場した夏季割引価格を保証する責任を負う様には作られていません．
    この様なアクシデントを防ぐために，単一の関心ごとについて責任を負わせるという「単一責任の原則」が重要とされています．

    https://qiita.com/MinoDriven/items/76307b1b066467cbfd6a


